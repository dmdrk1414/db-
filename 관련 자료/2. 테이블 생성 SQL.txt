# 테이블 생성
=====================================================

sql : 
CREATE TABLE attendance_status
(
	id                   INTEGER NOT NULL ,
	status               VARCHAR2(10) DEFAULT  ' '  NOT NULL ,
	attendance_time      DATE NOT NULL ,
	attendance_date      DATE NOT NULL ,
	member_id            INTEGER NOT NULL 
);


결과 : 
SQL> CREATE TABLE attendance_status
  2  (
  3  id                   INTEGER NOT NULL ,
  4  status               VARCHAR2(10) DEFAULT  ' '  NOT NULL ,
  5  attendance_time      DATE NOT NULL ,
  6  attendance_date      DATE NOT NULL ,
  7  member_id            INTEGER NOT NULL
  8  );

테이블이 생성되었습니다.

설명 : 
attendance_status 테이블 생성
=====================================================

sql : 
CREATE TABLE management
(
	id                   INTEGER NOT NULL ,
	renewal_date         DATE NOT NULL ,
	vacation_count       INTEGER DEFAULT  5  NOT NULL  CONSTRAINT  vacation_count_more_2123535537 CHECK (vacation_count >= 0),
	member_id            INTEGER NOT NULL 
);

결과 : 
SQL> CREATE TABLE management
  2  (
  3  id                   INTEGER NOT NULL ,
  4  renewal_date         DATE NOT NULL ,
  5  vacation_count       INTEGER DEFAULT  5  NOT NULL  CONSTRAINT  vacation_count_more_2123535537 CHECK (vacation_count >= 0),
  6  member_id            INTEGER NOT NULL
  7  );

테이블이 생성되었습니다.

설명 : 
management 테이블 생성
=====================================================

sql : 
CREATE TABLE member
(
	id                   INTEGER NOT NULL ,
	name                 VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
	email                VARCHAR2(40) DEFAULT  ' '  NULL ,
	password             VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
	grade                VARCHAR2(10) DEFAULT  ' '  NOT NULL ,
	phon_number          VARCHAR2(20) DEFAULT  ' '  NOT NULL 
);

결과 : 
SQL> CREATE TABLE member
  2  (
  3  id                   INTEGER NOT NULL ,
  4  name                 VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
  5  email                VARCHAR2(40) DEFAULT  ' '  NULL ,
  6  password             VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
  7  grade                VARCHAR2(10) DEFAULT  ' '  NOT NULL ,
  8  phon_number          VARCHAR2(20) DEFAULT  ' '  NOT NULL
  9  );

테이블이 생성되었습니다.

설명 : 
member 테이블 생성
=====================================================

sql : 
CREATE TABLE member_protfolio
(
	id                   INTEGER NOT NULL ,
	motivation_application VARCHAR2(50) DEFAULT  ' '  NOT NULL ,
	gpa                  VARCHAR2(20) DEFAULT  0.0  NOT NULL ,
	dream                VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
	member_id            INTEGER NOT NULL 
);

결과 : 
SQL> CREATE TABLE member_protfolio
  2  (
  3  id                   INTEGER NOT NULL ,
  4  motivation_application VARCHAR2(50) DEFAULT  ' '  NOT NULL ,
  5  gpa                  VARCHAR2(20) DEFAULT  0.0  NOT NULL ,
  6  dream                VARCHAR2(20) DEFAULT  ' '  NOT NULL ,
  7  member_id            INTEGER NOT NULL
  8  );

테이블이 생성되었습니다.

설명 : 
member_protfolio 테이블 생성
=====================================================

sql : 
CREATE TABLE post
(
	id                   INTEGER NOT NULL ,
	title                VARCHAR2(40) DEFAULT  ' '  NOT NULL ,
	content              VARCHAR2(100) DEFAULT  ' '  NULL ,
	post_date            DATE NOT NULL ,
	member_id            INTEGER NOT NULL 
);

결과 : 
SQL> CREATE TABLE post
  2  (
  3  id                   INTEGER NOT NULL ,
  4  title                VARCHAR2(40) DEFAULT  ' '  NOT NULL ,
  5  content              VARCHAR2(100) DEFAULT  ' '  NULL ,
  6  post_date            DATE NOT NULL ,
  7  member_id            INTEGER NOT NULL
  8  );

테이블이 생성되었습니다.

설명 : 
post 테이블 생성
=====================================================

sql : 
CREATE TABLE time_table
(
	id                   INTEGER NOT NULL ,
	image                VARCHAR2(60) DEFAULT  ' '  NULL ,
	apply_date           DATE NOT NULL ,
	member_id            INTEGER NOT NULL 
);

결과 : 
SQL> CREATE TABLE time_table
  2  (
  3  id                   INTEGER NOT NULL ,
  4  image                VARCHAR2(60) DEFAULT  ' '  NULL ,
  5  apply_date           DATE NOT NULL ,
  6  member_id            INTEGER NOT NULL
  7  );

테이블이 생성되었습니다.

설명 : 
time_table 테이블 생성
=====================================================

sql : 
CREATE TABLE week_data
(
	monday               NUMBER(1) DEFAULT 0 NOT NULL CHECK (monday IN (0, 1)),
	tuesday              NUMBER(1) DEFAULT 0 NOT NULL CHECK (tuesday IN (0, 1)),
	wednesday            NUMBER(1) DEFAULT 0 NOT NULL CHECK (wednesday IN (0, 1)),
	thursday             NUMBER(1) DEFAULT 0 NOT NULL CHECK (thursday IN (0, 1)),
	friday               NUMBER(1) DEFAULT 0 NOT NULL CHECK (friday IN (0, 1)),
	management_id        INTEGER NOT NULL ,
	member_id            INTEGER NOT NULL 
);

결과 : 
SQL> CREATE TABLE week_data
  2  (
  3  monday               NUMBER(1) DEFAULT 0 NOT NULL CHECK (monday IN (0, 1)),
  4  tuesday              NUMBER(1) DEFAULT 0 NOT NULL CHECK (tuesday IN (0, 1)),
  5  wednesday            NUMBER(1) DEFAULT 0 NOT NULL CHECK (wednesday IN (0, 1)),
  6  thursday             NUMBER(1) DEFAULT 0 NOT NULL CHECK (thursday IN (0, 1)),
  7  friday               NUMBER(1) DEFAULT 0 NOT NULL CHECK (friday IN (0, 1)),
  8  management_id        INTEGER NOT NULL ,
  9  member_id            INTEGER NOT NULL
 10  );

테이블이 생성되었습니다.

설명 : 
week_data 테이블 생성
=====================================================

sql : 
commit;

결과 : 
SQL> commit;

커밋이 완료되었습니다.

설명 : 
테이블 설정 저장
=====================================================



# 제약조건
=====================================================
sql : 
CREATE UNIQUE INDEX XPKattendance_status ON attendance_status
(id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKattendance_status ON attendance_status
  2  (id   ASC,member_id   ASC);

인덱스가 생성되었습니다.

설명 : 
 attendance_status 테이블에 대해 XPKattendance_status라는 이름의 고유 인덱스를 생성합니다. 
이 고유 인덱스는 id 및 member_id 열에 대해 오름차순(ASC)으로 정의됩니다.
=====================================================
sql : 
ALTER TABLE attendance_status
	ADD CONSTRAINT  XPKattendance_status PRIMARY KEY (id,member_id);

결과 : 
SQL> ALTER TABLE attendance_status
  2  ADD CONSTRAINT  XPKattendance_status PRIMARY KEY (id,member_id);

테이블이 변경되었습니다.

설명 : 
 attendance_status 테이블에 기본 키 제약 조건을 추가합니다. 
기본 키는 테이블의 각 행을 고유하게 식별

=====================================================
sql : 
CREATE UNIQUE INDEX XPKmanagement ON management
(id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKmanagement ON management
  2  (id   ASC,member_id   ASC);

인덱스가 생성되었습니다.

설명 : 
management 테이블에 대해 XPKmanagement라는 이름의 고유 인덱스를 만듭니다. 이 인덱스는 id 및 member_id 열의 조합에 대해 오름차순(ASC)으로 정의됩니다. 
고유 인덱스는 특정 열 또는 열의 조합에 대해 중복 값을 허용하지 않는다

=====================================================
sql : 
ALTER TABLE management
	ADD CONSTRAINT  XPKmanagement PRIMARY KEY (id,member_id);

결과 : 
SQL> ALTER TABLE management
  2  ADD CONSTRAINT  XPKmanagement PRIMARY KEY (id,member_id);

테이블이 변경되었습니다.


설명 : 
 management 테이블에 새로운 기본 키 제약 조건을 추가합니다. 
이 제약 조건은 id 및 member_id 열의 조합이 해당 테이블 내에서 고유하도록 강제합니다. 다시 말해, 
동일한 id 및 member_id 값을 가진 두 개 이상의 행을 허용하지 않습니다.

=====================================================
sql : 
CREATE UNIQUE INDEX XPKmember ON member
(id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKmember ON member
  2  (id   ASC);

인덱스가 생성되었습니다.

설명 : 
 member 테이블에 대해 XPKmember라는 이름의 고유 인덱스를 만듭니다. 
이 인덱스는 id 열에 대해 오름차순(ASC)으로 정의됩니다. 
고유 인덱스는 특정 열에 대해 중복 값을 허용하지 않는다.

=====================================================
sql : 
ALTER TABLE member
	ADD CONSTRAINT  XPKmember PRIMARY KEY (id);

결과 : 
SQL> ALTER TABLE member
  2  ADD CONSTRAINT  XPKmember PRIMARY KEY (id);

테이블이 변경되었습니다.

설명 : 
 member 테이블에 새로운 기본 키 제약 조건을 추가합니다. 이 제약 조건은 id 열이 해당 테이블 내에서 고유하도록 강제합니다.

=====================================================
sql : 
CREATE UNIQUE INDEX XAK1member ON member
(email   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XAK1member ON member
  2  (email   ASC);

인덱스가 생성되었습니다.

설명 : 
member 테이블에 대해 XAK1member라는 이름의 고유 인덱스를 만듭니다. 
이 인덱스는 email 열에 대해 오름차순(ASC)으로 정의됩니다. 
고유 인덱스는 특정 열에 대해 중복 값을 허용하지 않는다.

=====================================================
sql : 
ALTER TABLE member
ADD CONSTRAINT  XAK1member UNIQUE (email);

결과 : 
SQL> ALTER TABLE member
  2  ADD CONSTRAINT  XAK1member UNIQUE (email);

테이블이 변경되었습니다.

설명 : 
 member 테이블에 XAK1member라는 이름의 고유성 제약 조건을 추가합니다. 
이 제약 조건은 email 열에 대해 고유해야 한다는 것을 나타냅니다. 
따라서 member 테이블 내에서 동일한 email 값을 가진 두 개 이상의 행을 허용하지 않습니다

=====================================================
sql : 
CREATE UNIQUE INDEX XPKmember_protfolio ON member_protfolio
(id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKmember_protfolio ON member_protfolio
  2  (id   ASC,member_id   ASC);

인덱스가 생성되었습니다.

설명 : 
 member_protfolio 테이블에 대해 XPKmember_protfolio라는 이름의 고유 인덱스를 만듭니다. 
이 인덱스는 id 및 member_id 열의 조합에 대해 오름차순(ASC)으로 정의됩니다. 
고유 인덱스는 특정 열 또는 열의 조합에 대해 중복 값을 허용하지 않는다.

=====================================================
sql : 
ALTER TABLE member_protfolio
	ADD CONSTRAINT  XPKmember_protfolio PRIMARY KEY (id,member_id);

결과 : 
SQL> ALTER TABLE member_protfolio
  2  ADD CONSTRAINT  XPKmember_protfolio PRIMARY KEY (id,member_id);

테이블이 변경되었습니다.

설명 : 

member_protfolio 테이블에 새로운 기본 키 제약 조건을 추가합니다. 
이 제약 조건은 id 및 member_id 열의 조합이 해당 테이블 내에서 고유하도록 강제합니다. 
다시 말해, 동일한 id 및 member_id 값을 가진 두 개 이상의 행을 허용하지 않습니다. 
=====================================================
sql : 
CREATE UNIQUE INDEX XPKpost ON post
(id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKpost ON post
  2  (id   ASC,member_id   ASC);

인덱스가 생성되었습니다.

설명 : 
post 테이블에 대해 XPKpost라는 이름의 고유 인덱스를 만듭니다. 
이 인덱스는 id 및 member_id 열의 조합에 대해 오름차순(ASC)으로 정의됩니다. 
고유 인덱스는 특정 열 또는 열의 조합에 대해 중복 값을 허용하지 않는다.

=====================================================
sql : 
ALTER TABLE post
	ADD CONSTRAINT  XPKpost PRIMARY KEY (id,member_id);

결과 : 
SQL> ALTER TABLE post
  2  ADD CONSTRAINT  XPKpost PRIMARY KEY (id,member_id);

테이블이 변경되었습니다.


설명 : 

post 테이블에 새로운 기본 키 제약 조건을 추가합니다. 
이 제약 조건은 id 및 member_id 열의 조합이 해당 테이블 내에서 고유하도록 강제합니다. 
다시 말해, 동일한 id 및 member_id 값을 가진 두 개 이상의 행을 허용하지 않습니다. 
=====================================================
sql : 
CREATE UNIQUE INDEX XPKtime_table ON time_table
(id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKtime_table ON time_table
  2  (id   ASC,member_id   ASC);

인덱스가 생성되었습니다.

설명 : 
 "time_table"이라는 테이블에 대한 고유 인덱스를 생성하는 것입니다. 
이 인덱스의 이름은 "XPKtime_table"이며, 
해당 인덱스는 "id" 및 "member_id" 열에 대해 고유해야 합니다.

=====================================================
sql : 
ALTER TABLE time_table
	ADD CONSTRAINT  XPKtime_table PRIMARY KEY (id,member_id);

결과 : 
SQL> ALTER TABLE time_table
  2  ADD CONSTRAINT  XPKtime_table PRIMARY KEY (id,member_id);

테이블이 변경되었습니다.


설명 : 
 "time_table" 테이블에 대한 기본 키(primary key) 제약 조건을 추가하는 것입니다. 
이 기본 키의 이름은 "XPKtime_table"이며, 해당 기본 키는 "id" 및 "member_id" 열의 조합으로 구성됩니다.

=====================================================
sql : 
CREATE UNIQUE INDEX XPKweek_data ON week_data
(management_id   ASC,member_id   ASC);

결과 : 
SQL> CREATE UNIQUE INDEX XPKweek_data ON week_data
  2  (management_id   ASC,member_id   ASC);

인덱스가 생성되었습니다.


설명 : 
 "week_data" 테이블에 대한 고유 인덱스를 생성하는 것입니다. 
이 인덱스의 이름은 "XPKweek_data"이며, 
해당 인덱스는 "management_id" 및 "member_id" 열에 대해 고유해야 합니다.

=====================================================
sql : 
ALTER TABLE week_data
	ADD CONSTRAINT  XPKweek_data PRIMARY KEY (management_id,member_id);

결과 : 
SQL> ALTER TABLE week_data
  2  ADD CONSTRAINT  XPKweek_data PRIMARY KEY (management_id,member_id);

테이블이 변경되었습니다.


설명 : 
"week_data" 테이블에 대한 기본 키(primary key) 제약 조건을 추가하는 것입니다.
 이 기본 키의 이름은 "XPKweek_data"이며, 
해당 기본 키는 "management_id" 및 "member_id" 열의 조합으로 구성됩니다.

=====================================================
sql : 
ALTER TABLE attendance_status
	ADD (CONSTRAINT R_11 FOREIGN KEY (member_id) REFERENCES member (id));

결과 : 
SQL> ALTER TABLE attendance_status
  2  ADD (CONSTRAINT R_11 FOREIGN KEY (member_id) REFERENCES member (id));

테이블이 변경되었습니다.


설명 : 
 "attendance_status" 테이블에 대한 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 
이 외래 키의 이름은 "R_11"이며, 해당 외래 키는 "member_id" 열을 참조하여 "member" 테이블의 "id" 열과 연결됩니다.

=====================================================
sql : 
ALTER TABLE management
	ADD (CONSTRAINT R_16 FOREIGN KEY (member_id) REFERENCES member (id));

결과 : 
SQL> ALTER TABLE management
  2  ADD (CONSTRAINT R_16 FOREIGN KEY (member_id) REFERENCES member (id));

테이블이 변경되었습니다.

설명 : 
 "management" 테이블에 대한 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 
이 외래 키의 이름은 "R_16"이며, 해당 외래 키는 "member_id" 열을 참조하여 "member" 테이블의 "id" 열과 연결됩니다.

=====================================================
sql : 
ALTER TABLE member_protfolio
	ADD (CONSTRAINT R_14 FOREIGN KEY (member_id) REFERENCES member (id));

결과 : 
SQL> ALTER TABLE member_protfolio
  2  ADD (CONSTRAINT R_14 FOREIGN KEY (member_id) REFERENCES member (id));

테이블이 변경되었습니다.

설명 : 
 "member_portfolio" 테이블에 대한 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 
이 외래 키의 이름은 "R_14"이며, 해당 외래 키는 "member_id" 열을 참조하여 "member" 테이블의 "id" 열과 연결됩니다.

=====================================================
sql : 
ALTER TABLE post
	ADD (CONSTRAINT R_13 FOREIGN KEY (member_id) REFERENCES member (id));

결과 : 
SQL> ALTER TABLE post
  2  ADD (CONSTRAINT R_13 FOREIGN KEY (member_id) REFERENCES member (id));

테이블이 변경되었습니다.

설명 : 
 "post" 테이블에 대한 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 이 외래 키의 이름은 "R_13"이며, 
해당 외래 키는 "member_id" 열을 참조하여 "member" 테이블의 "id" 열과 연결됩니다.

=====================================================
sql : 
ALTER TABLE time_table
	ADD (CONSTRAINT R_12 FOREIGN KEY (member_id) REFERENCES member (id));

결과 : 
SQL> ALTER TABLE time_table
  2  ADD (CONSTRAINT R_12 FOREIGN KEY (member_id) REFERENCES member (id));

테이블이 변경되었습니다.

설명 : 
 "time_table" 테이블에 대한 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 이 외래 키의 이름은 "R_12"이며, 
해당 외래 키는 "member_id" 열을 참조하여 "member" 테이블의 "id" 열과 연결됩니다.

=====================================================
sql : 
ALTER TABLE week_data
	ADD (CONSTRAINT R_9 FOREIGN KEY (management_id, member_id) REFERENCES management (id, member_id));

결과 : 
SQL> ALTER TABLE week_data
  2  ADD (CONSTRAINT R_9 FOREIGN KEY (management_id, member_id) REFERENCES management (id, member_id));

테이블이 변경되었습니다.


설명 : 
 "week_data" 테이블에 대한 복합 외래 키(Foreign Key) 제약 조건을 추가하는 것입니다. 
이 외래 키의 이름은 "R_9"이며, 해당 외래 키는 "management_id" 및 "member_id" 열을 참조하여 
"management" 테이블의 "id" 및 "member_id" 열과 연결됩니다.

=====================================================
sql : 
commit;

결과 : 
SQL> commit;

커밋이 완료되었습니다.

설명 : 
제약 조건 설정 반영.

=====================================================
